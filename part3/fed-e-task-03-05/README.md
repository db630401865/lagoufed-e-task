## 简答题

（请直接在本文件中作答）

#### 1、Vue 3.0 性能提升主要是通过哪几方面体现的？

　Vue3.0的源码全部使用Typescript写的。使用Monorepo方式组织结构，把独立的模块都提取到不同的包中， 3.x的90%的Api兼容2.x. 
 增加了CompositionApi,用来解决2.x遇到大型项目的时候遇到超大组件需要CompositionApi解决不好拆分和重用的问题
 性能提升：重写了响应式的代码，并且对编译器做了优化，重写了虚拟dom。从而让update有了更大的提升。官方宣布服务端渲染提升了2-3倍，
 VIte:使用vite在开发过程中，不需要打包，直接可以运行项目，提升了开发效率
 使用proxy对象重写了响应式系统
 通过优化编译过程和重写dom，提升渲染的性能，通过优化代码的体积，去更好的支持terr-shaking.减少打包的体积
在虚拟dom中，diff算法是最耗时的，vue2中，重新渲染的时候需要重新创建新旧vnode.diff的时候回跳过静态根节点，对比剩下的每一个新旧vnode.哪怕这个节点什么都没做， Vue3中，通过标记和提升静态节点以及patch flag标记动态节点来大大提升了diff的性能。通过对事件处理函数的缓存，减少了不必要的操作
　 除了响应式系统升级以外，Vue3通过优化编译的功能和重写虚拟dom,让首次渲染和更新的性能有了大幅度的提升

　

#### 2、Vue 3.0 所采用的 Composition Api 与 Vue 2.x使用的Options Api 有什么区别？

setup函数是 Composition API（组合API）的入口setup函数是处于 生命周期函数 beforeCreate 和 Created 两个钩子函数之间的函数 也就说在 setup函数中是无法 使用 data 和 methods 中的数据和方法的 在setup函数中定义的变量和方法最后都是需要 return 出去的 不然无法再模板中使用setup返回的对象，可以使用在模版，生命周期的钩子函数中执行时机，在porps解析完毕但是在组件实例被创建之前执行的。etUp是在beforeCreate和created之间执行的。 Composition API的好处可以将在Options Api中data数据，mounted等等生命周期中的属性和方法抽离出来，封装成方法，可以在调用的时候直接使用，不用再去一个个去寻找。这样更方便了代码的重用。不受模板和组件范围的限制，直接查看方法就知道我们组件的使用方式。
例如封装一个组件，如果在Vue 2.x中，我们会在data定义属性,methods定义方法，mounted等生命周期调用方法。得需要很多地方，
如果在Vue 3.0 中使用 Composition Api。我们就可以封装成一个方法，在莫个需要的地方直接调用就可以了。更好的复用。可以更灵活的组织代码逻辑
　

　

#### 3、Proxy 相对于 Object.defineProperty 有哪些优点？

　vue2.0,通过使用defineProperty属性，遍历每一个对象，为其设置getter,setter,如果data对象中又是对象的话，需要递归处理每一个子对象的属性，这些都是在初始化的时候进行的，如果没有使用的是也会进行响应式的处理
 vue3.0使用的是es6新增的proxy对象，proxy对象性能本身就比defineProperty要好。代理对象可以拦截对象的访问，删除等操作，不需要初始化的时候遍历所有的属性，如果有多层属性嵌套的话， 只有访问莫个属性的时候才会去递归处理下一级的属性。使用proxy对象就可以动态监听添加的属性，而vue2里面，想要动态添加一个属性需要调用set方法进行处理，而且vue2中监听不到删除属性，对数组的索引和length属性的修改也监听不到。Vue3里面就可以监听到删除属性，和监听到数组的索引和length属性的操作。所以vue3使用proxy对象提升了性能和响应式功能


　

　

#### 4、Vue 3.0 在编译方面有哪些优化？

vue2 中使用就是vue-template-compiler编译
vie2 使用vue-cli-service，它内部会使用webpack首先去打包所有的模块，如果模块比较多的话，打包速度就比较慢，把打包的结果存储到内存中，开会开启web的开发服务器，浏览器请求服务器，把打包的结果直接返回给浏览器。
webpack这类工具是将所有的模块提前编译打包进bundle里，不管模块是否被使用到，也会打包到bundle 里，所以项目越来越大，打包的bundle越来越大，自然也就越来越慢


vue3 使用@vue/compiler-sfc编译项目中的.vue结尾的单文件组件。
Vite 利用浏览器原生指出的esModule模块化的特性，省略了对模块的打包。对需要编译的文件。
vite开启一个web开发服务器，在启动服务器的时候不需要编译所有的代码，编译是在服务器端，模块的处理是在请求到服务器端处理的。vite会加载2次单文件请求，第一次请求是吧单文件组件编译成一个对象，第二次请求是编译成单文件模版。返回一个render函数，并且吧render函数挂载到创建对象的render方法上。之后渲染模版到页面。真正实现了按需加载

例如单文件组件，样式模块等，vite采用了计时编译（按需编译，速度会很快）。也就是具体去请求莫个文件的时候，才会在服务端编译这个文件，vite的热更新比webpack的热更新更好，因为只需要立即编译所修改的文件。

　

　

　

#### 5、Vue.js 3.0 响应式系统的实现原理？

使用es6的proxy对象实现属性监听，可以多层嵌套属性子在访问属性过程中处理下一级属性，默认监听动态添加属性，删除操作，监听数组和length属性。创建拦截器对象handler，设置对应的get/set/deleteProperty方法，返回proxy对象。其中get方法内部调用track方法收集依赖，target参数可以能是对象，递归调用使其变成响应式对象。track函数首先根据targetMap对象来找到depsMap()，如果没有找到的还给当前对象创建一个depsMap,并添加到targetMap中，如果找到了再根据当前使用的属性来depsMap找到对应的dep().dep()中储存的是effect函数，如果没有找到的话，为当前属性创建dep，并且存储到 depsMap中，如果找到了当前属性对应的集合，那就吧当前effect函数存储到当前集合中。其中set内部对比是否有新旧数据变化，如果有触发更新。调用trigger方法。通过target获取targetMap中的目标对象，通过目标对象获取到属性名称，通过属性名称循环遍历effect方法，执行更新操作。deleteProperty方法是实现删除属性的。
所以当我们使用响应式的reactive/ref/useRefs方法的时候，会调用proxy对象的get方法，是对象的每个数据都会有set,get,deleteProperty方法.当响应式数据改变的时候，会调用set方法，从而触发trigger方法更新。
　