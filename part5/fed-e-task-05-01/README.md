## 简答题

#### 1.简述 Node.js 的特点以及适用的场景。

node特点
  可以做轻量级高性能的web服务，
  可以前后端同构开发
  便捷高效的前端工程化
  异步io
  事件驱动
  单线程
  事件循环等

node缺点
  node.js更适合io密集型任务
  不适合处理大量的业务逻辑。计算能力不是特色

应用场景
  非阻塞io的操作。可以执行密集型高并发请求
  操作数据库提供api服务
  实时聊天应用程序

#### 2.简述 Buffer 的使用.包括多种创建方式。实例方法，静态方法。

Buffer创建方式有3种
常用的是Burrer.from,Buffer.alloc
不常用的Buffer.allocUnsafe(不安全的)

Buffer的实例方法
fill 使用数据填充buffer
write 向buffer写入数据
toString 从buffer中提取数据
slice 截取buffer
indexOf 在buffer中查找数据
copy 拷贝buffer的数据

Buffer的静态方法
concat 将多个buffer合并成一个新的Buffer
isBuffer 判断数据是否为buffer

#### 3.写出5个以上文件操作的API，并且用文字说明其功能。

readFile 从指定文件中读取数据
writeFile 从指定文件中写入数据
appendFile 追加的方式向指定文件中写入数据
copyFile 将莫个文件中的数据拷贝至另一文件
watchFile 对指定文件进行监控


#### 4.简述使用流操作的优势，以及Node中流的分类。

流操作的优势
时间效率：流的分段处理可以同时操作多个数据chunk
空间效率：同一时间流无需占据大内存空间
使用方便：流配合管理，扩展程序变的简单

流分4种
readable: 可读流，能够实现数据的读取
writeable: 可写流，能狗实现数据的写入
Duplex: 双工流，既可读又可写
Tranfrom: 转换流，实现读写的数据的转换

#### 5.在数据封装与解封装过程中，针对应用层、传输层、网络层、数据链路层、物理层5层分别做了什么事情？

第一步：应用层产出真正要被传输的数据（data表示）。然后数据传入传输层
第二步：传输层最常见的就是TCP，和UDP协议。这2个协议是基于端口的，端口的作用是在主机上用于唯一确定一个应用进程。所以数据在这层上面会被包裹上目标端口，和应用当前主机上的源端口
第三步：数据传向网络层，因为我们的主机都是处于不同的网络里的，所以我们需要通过IP协议去确定目标主机所在的网路，因此数据在这层当中会被包裹上目标主机的IP，与当前主机的源IP，有了这些信息我们能确定莫一个网络，并不能去确定在这个里面到底哪一台机器是我们想要的，所以数据就到达了数据链路层
第四步：数据就到达数据链路层。这一层最主要的就是通过mac地址来完成寻址操作。所以数据在这层当中，会被包裹上目标主机的mac地址与当前主机的mac地址。此时就具有一条完整的信息就被封装好了。
第五步：这时就需要传递给网络。网线是不能识别二进制的，经过网卡的调制之后就会变成高低电压，此时依然使用二进制表示转换后的数据。有了这些数据之后，经过路由器的网络分配和传输介质的运输，最终到达了目标主机的网卡
第六步：到达目标网卡，这时候首先去进行数据的解调，将电压变成二进制。然后再想上层传递至链路层
第七步：链路层，这时候去分析一下目标mac地址是不是当前主机的mac地址，如果是则继续向上传递至网络层
第八步：网络层，在这层就要去看一下目标的IP是不是当前自己的ip 。如果是则继续拆包，继续向上传输至传输层
第九步：传输层，再去确定一下当前的目标端口是不是自己，如果是继续拆解数据则向上传递至应用层
第十步：应用层，当前网络里的目标主机的应用也就拿到了由另外一个网络当中的莫一台主机的莫一个应用所传递过来的数据。这个过程就是数据在通讯过程中的封装与解封的步骤

## 代码题


#### 1.统计指定目录中文件总大小。要考虑目录中还有子目录的情况。可以同步编码,异步更好。
01.js

#### 2.编写单向链表类并且实现队列的入列出列操作。
02.js

#### 3.基于Node写出一静态服务器。接收请求并且响应特定目录(服务器目录)中的html、css、js、图片等资源。
03.js
