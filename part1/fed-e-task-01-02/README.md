# Part1-2 作业

( 请在当前文件直接作答 )

## 简答题

### 1. 请说出下列最终执行结果，并解释为什么?

```javascript
var a = []
for (var i = 0; i < 10; i++) {
  a[i] = function () {
    console.log(i)
  }
}
a[6]()
```

10.因为 a 是全局变量,变量声明提升，var i 变量声明提升，当我们在调用的时候。a[6]的时候其实是返回的一个函数体，当我们在调用的时候，for 循环已经执行 10 次了，没办法保存当前的 i，如果使用闭包或者 var 改成 let，就会输出 6.

### 2. 请说出此案列最终执行结果，并解释为什么?

```javascript
var tmp = 123
if (true) {
  console.log(tmp)
  let tmp
}
```

回报错，因为在 if()语句中，let 是块级作用域，局部变量,当执行到他哪一行时候才会执行，在此之前 console.log(tmp)是找不到到

### 3. 结合 ES6 语法，用最简单的方式找出数组中的最小值

```javascript
var arr = [12, 34, 32, 89, 4]
```

Math.min(...arr)

### 4. 请详细说明 var、let、const 三种声明变量的方式之间的具体差别

var 会变量声明提升
let 和 const 不会变量声明提升，是块级作用域，局部变量,let 适用变量
但是 const 声明的变量是不可以修改的，但是 const 定义的数组和对象是可以进行添加和修改其中的元素的,经常定义常量等

### 5. 请说出下列代码最终输出结果，并解释为什么？

```javascript
var a = 10
var obj = {
  a: 20,
  fn() {
    setTimeout(() => {
      console.log(this.a)
    })
  },
}
obj.fn()
```

20
对于对象调用自己的函数时，this 是指向自己的。obj 属性有 a,并且等于 20。所以打印 20

### 6. 简述 Symbol 类型的用途

Symbol 类型作为唯一性，无法被重建的基本类型，可以适用于储存数据，这样就不会有键值重复的问题

### 7. 说说什么是浅拷贝，什么是深拷贝？

浅拷贝：考贝对象里面的数据，但是不拷贝对象里面的子对象等属性。指向一个堆内存空间
深拷贝：会克隆出一个对象，数据相同，但是引用地址不同，开辟一个新的堆内存空间

### 8. 请简述 TypeScript 与 JavaScript 之间的关系？

JavaScript 和 TypeScript 都是 ECMAScript
TypeScript 被真正执行前，会通过编译转换生成 JavaScript，之后才能被解释执行
TypeScript 是 javaScript 的扩展级
任何一种 javaScript 运行的环境都支持 TypeScript

### 9. 请谈谈你所认为的 typescript 优缺点

优点：
TypeScript 增加了代码的可读性和可维护性
TypeScript 拥有活跃的社区
可以定义从简单到复杂的几乎一切类型
TypeScript 是 JavaScript 的超集
即使 TypeScript 编译报错，也可以生成 JavaScript 文件
兼容第三方库，即使第三方库不是用 TypeScript 写的，也可以编写单独的类型文件供 TypeScript 读取
大部分第三方库都有提供给 TypeScript 的类型定义文件
Google 开发的 Angular2 就是使用 TypeScript 编写的
VUE3.0,React,等都在拥抱 typescript
缺点：
有一定的学习成本，需要理解接口、泛型、类、枚举类型等概念
短期可能会增加一些开发成本，毕竟要多写一些类型的定义，不过对于一个需要长期维护的项目，TypeScript 能够减少其维护成本
集成到构建流程需要一些工作量

### 10. 描述引用计数的工作原理和优缺点

靠着当前对象身上的一个引用计数的数值，来判断是否为 0， 是否是一个垃圾对象，从而进行回收
内存会不断计算每个对象的引用计数的数值，会有很大的开销。遇到循环引用就没办法进行垃圾回收

### 11. 描述标记整理算法的工作流程

标记整理算法就是在引用计数的流程之上多了空间随便的整合排序，释放

### 12.描述 V8 中新生代存储区垃圾回收的流程

新生代垃圾回收是分为 from 和 to 2 个空间，回收使用复制算法+标记整理。活动对象储存在 from。标记整理后把可达对象，使用复制算法拷贝到 to 空间，最后在进行置换，完成空间释放过程

### 13. 描述增量标记算法在何时使用及工作原理

量标记算法是针对老年代的储存区域。 所以我们存在遍历的操作，遍历的时候我们要做标记的操作，这个标记可以不一口气做完，因为它存在着的一个直接可达和间接可达的操作，也就是说，我们在做的时候，第一步先找到第一层的可达对象，那么我们就可以停下来了，让程序继续执行，程序执行一会之后，让 GC 执行第二步的标记操作，比如他的下边会有一些子元素也是可达的，那我们就继续去把它做一个标记，那么我们标记一轮之后，再让 GC 停下来，让程序继续执行，也就是所谓的交替的事情 。那么我们的标记操作完成以后，我们最终就会完成我们的垃圾回收了，那么这样的一长段时间里我们就去完成垃圾回收操作， 而程序就停留在此区域， 最终当我们完成了垃圾回收操作之后，在程序继续回到他该执行的地方去执行 ，当我们 15G 内存满的时候也就是使用 1 秒钟。所以我们这样区分开一小段，一小段，对用户的体验显得更加好一些。
